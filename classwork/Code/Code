#include <iostream>
#include <fstream>
#include <vector>
#include <thread>
#include <chrono>
#include <algorithm>

using namespace std;

enum LogLevel { INFO, DEBUG, WARNING, ERROR };

class Logger {
public:
    static void log(LogLevel level, const string& message) {
        ofstream logFile("job_log.txt", ios::app);
        string levelStr;
        switch (level) {
            case INFO: levelStr = "[INFO] "; break;
            case DEBUG: levelStr = "[DEBUG] "; break;
            case WARNING: levelStr = "[WARNING] "; break;
            case ERROR: levelStr = "[ERROR] "; break;
        }
        cout << levelStr << message << endl;
        logFile << levelStr << message << endl;
        logFile.close();
    }
};

struct Job {
    int jobID;
    int executionTime;
    int priority;

    Job(int id, int time, int prio) : jobID(id), executionTime(time), priority(prio) {}
};

class JobScheduler {
private:
    vector<Job> jobs;
    void (*scheduleFunc)(vector<Job>&) = nullptr;

public:
    void loadJobs(const string& filename) {
        ifstream file(filename);
        jobs.clear();
        if (!file) {
            Logger::log(ERROR, "File could not be opened.");
            return;
        }

        int id, time, prio;
        while (file >> id >> time >> prio) {
            jobs.emplace_back(id, time, prio);
        }

        file.close();
        Logger::log(INFO, "Successfully loaded " + to_string(jobs.size()) + " jobs.");
    }

    static void fifoScheduling(vector<Job>& jobs) {
        sort(jobs.begin(), jobs.end(), [](const Job& a, const Job& b) {
            return a.jobID < b.jobID;
        });
        Logger::log(DEBUG, "Sorted jobs by FIFO (Job ID).");
    }

    static void priorityScheduling(vector<Job>& jobs) {
        sort(jobs.begin(), jobs.end(), [](const Job& a, const Job& b) {
            return a.priority > b.priority;
        });
        Logger::log(DEBUG, "Sorted jobs by Priority.");
    }

    void chooseScheduling(char choice) {
        if (choice == 'a') {
            scheduleFunc = fifoScheduling;
            Logger::log(INFO, "Selected FIFO Scheduling.");
        } else if (choice == 'b') {
            scheduleFunc = priorityScheduling;
            Logger::log(INFO, "Selected Priority Scheduling.");
        } else {
            Logger::log(WARNING, "Invalid scheduling choice.");
        }
    }

    void executeJobs() {
        if (!scheduleFunc || jobs.empty()) {
            Logger::log(WARNING, "Scheduling not chosen or jobs not loaded.");
            return;
        }

        scheduleFunc(jobs);

        int totalTime = 0;
        for (const auto& job : jobs) {
            Logger::log(DEBUG, "Executing Job ID: " + to_string(job.jobID) + " | Priority: " + to_string(job.priority));
            this_thread::sleep_for(chrono::milliseconds(job.executionTime));
            totalTime += job.executionTime;
        }
        Logger::log(INFO, "All jobs executed in " + to_string(totalTime) + "ms.");
    }

    void runMenu() {
        char choice;

        while (true) {
            cout << "\n==== JobChain Scheduler ====" << endl;
            cout << "1. Load jobs from file\n2. Choose scheduling algorithm\n3. Execute jobs\n4. Export log\n5. Exit" << endl;
            cout << "> ";
            cin >> choice;

            switch (choice) {
                case '1':
                    loadJobs("jobs.txt");
                    break;
                case '2':
                    cout << "Choose scheduling algorithm:\n   a. FIFO (Job ID)\n   b. Priority-based" << endl;
                    cout << "> ";
                    cin >> choice;
                    chooseScheduling(choice);
                    break;
                case '3':
                    executeJobs();
                    break;
                case '4':
                    Logger::log(INFO, "Log saved to job_log.txt.");
                    break;
                case '5':
                    return;
                default:
                    Logger::log(WARNING, "Invalid choice.");
            }
        }
    }
};

int main() {
    JobScheduler scheduler;
    scheduler.runMenu();
    return 0;
}
